<?php
/**
 * @category    Joomla component
 * @package     THM_Organizer
 * @subpackage  com_thm_organizer.admin
 * @name        THM_OrganizerModelSchedule
 * @author      James Antrim, <james.antrim@nm.thm.de>
 * @copyright   2016 TH Mittelhessen
 * @license     GNU GPL v.2
 * @link        www.thm.de
 */
defined('_JEXEC') or die;
JTable::addIncludePath(JPATH_BASE . '/administrator/components/com_thm_organizer/tables');
/** @noinspection PhpIncludeInspection */
require_once JPATH_ROOT . '/media/com_thm_organizer/helpers/xml/schedule.php';
require_once JPATH_ROOT . '/media/com_thm_organizer/helpers/json/schedule.php';

/**
 * Class enapsulating data abstraction and business logic for xml schedules
 * generated by Untis software.
 *
 * @category    Joomla.Component.Admin
 * @package     thm_organizer
 * @subpackage  com_thm_organizer.admin
 */
class THM_OrganizerModelOldJSONSchedule extends JModelLegacy
{
	/**
	 * Object containing information from the actual schedule
	 *
	 * @var object
	 */
	private $schedule = null;

	/**
	 * Object containing information from a reference schedule
	 *
	 * @var object
	 */
	private $compSchedule = null;

	/**
	 * Removes delta information from a schedule
	 *
	 * @param object &$schedule the schedule being processed
	 *
	 * @return void
	 */
	public function sanitize(&$schedule)
	{
		$this->sanitizeLessons($schedule->lessons);
		$this->sanitizeCalendar($schedule->calendar);
		if (isset($schedule->referenceID))
		{
			unset($schedule->referenceID);
		}
	}

	/**
	 * sanitizes a given lesson property
	 *
	 * @param array &$property the array holding information about the property
	 *
	 * @return void
	 */
	private function sanitizeLessonProperty(&$property)
	{
		foreach ($property as $key => $value)
		{
			switch ($value)
			{
				case 'new':
					$property->$key = '';
					continue;
				case '':
					continue;
				case 'removed':
					unset($property->$key);
					continue;
			}
		}
	}

	/**
	 * removes delta information from a schedule
	 *
	 * @param array &$lessons the currently active schedule lessons
	 *
	 * @return void
	 */
	private function sanitizeLessons(&$lessons)
	{
		foreach ($lessons as $lessonKey => $lesson)
		{
			if (isset($lesson->delta))
			{
				switch ($lesson->delta)
				{
					case 'new':
						unset($lessons->$lessonKey->delta);
						continue;
					case 'removed':
						unset($lessons->$lessonKey);
						continue;
					case 'changed':
						$this->sanitizeLessonProperty($lessons->$lessonKey->subjects);
						$this->sanitizeLessonProperty($lessons->$lessonKey->teachers);
						$this->sanitizeLessonProperty($lessons->$lessonKey->pools);
						unset($lessons->$lessonKey->delta);
						continue;
				}
			}
		}
	}

	/**
	 * sanitizes the calendar array of delta information
	 *
	 * @param array &$calendar the calendar data to be sanitized
	 *
	 * @return void
	 */
	private function sanitizeCalendar(&$calendar)
	{
		foreach ($calendar as $date => $periods)
		{
			if (!is_object($calendar->$date) OR empty($periods))
			{
				continue;
			}

			foreach ($periods as $period => $lessons)
			{
				if (empty($lessons))
				{
					continue;
				}

				foreach ($lessons as $lesson => $rooms)
				{
					if (empty($calendar->$date->$period->$lesson->delta))
					{
						continue;
					}

					switch ($calendar->$date->$period->$lesson->delta)
					{
						case 'new':
							unset($calendar->$date->$period->$lesson->delta);
							break;
						case 'removed':
							unset($calendar->$date->$period->$lesson);
							break;
						case 'changed':
							foreach ($rooms as $roomID => $delta)
							{
								if ($roomID == 'delta')
								{
									continue;
								}

								switch ($delta)
								{
									case 'new':
										$calendar->$date->$period->$lesson->$roomID = '';
										continue;
									case '':
										continue;
									case 'removed':
										unset($calendar->$date->$period->$lesson->$roomID);
										continue;
								}
							}
							unset($calendar->$date->$period->$lesson->delta);
							break;
					}
				}
			}
		}
	}

	/**
	 * Examines the calendars of the actual and the reference schedules to
	 * determine changes
	 *
	 * @param object &$calendar    the calendar of the actual schedule
	 * @param object &$refCalendar the calendar of the reference schedule
	 *
	 * @return void
	 */
	private function setCalendarReference(&$calendar, &$refCalendar)
	{
		foreach ($calendar as $date => $periods)
		{
			if (!is_object($calendar->$date) OR empty($periods))
			{
				continue;
			}

			foreach ($periods as $period => $lessons)
			{
				if (empty($lessons))
				{
					continue;
				}

				foreach ($lessons as $lessonID => $rooms)
				{
					if (!isset($refCalendar->$date->$period->$lessonID))
					{
						$calendar->$date->$period->$lessonID->delta = 'new';
						continue;
					}
					else
					{
						foreach ($rooms as $roomID => $delta)
						{
							if ($roomID == 'delta' or empty($roomID))
							{
								continue;
							}

							if (!isset($refCalendar->$date->$period->$lessonID->$roomID))
							{
								$calendar->$date->$period->$lessonID->$roomID = 'new';
								$calendar->$date->$period->$lessonID->delta   = 'changed';
								continue;
							}
						}
					}
				}
			}
		}

		foreach ($refCalendar as $date => $periods)
		{
			$invalidDate = (empty($calendar->$date) OR !is_object($calendar->$date) OR empty($periods));
			if ($invalidDate)
			{
				continue;
			}

			foreach ($periods as $period => $lessons)
			{
				if (empty($lessons))
				{
					continue;
				}

				foreach ($lessons as $lessonID => $rooms)
				{
					if (!isset($calendar->$date->$period->$lessonID))
					{
						$calendar->$date->$period->$lessonID = new stdClass;
						foreach ($rooms as $roomID => $delta)
						{
							$calendar->$date->$period->$lessonID->$roomID = '';
						}

						$calendar->$date->$period->$lessonID->delta = 'removed';
						continue;
					}

					foreach ($rooms as $roomID => $delta)
					{
						if ($roomID == 'delta')
						{
							continue;
						}

						if (!isset($calendar->$date->$period->$lessonID->$roomID))
						{
							$calendar->$date->$period->$lessonID->$roomID = 'removed';
							$calendar->$date->$period->$lessonID->delta   = 'changed';
							continue;
						}
					}
				}
			}
		}
	}

	/**
	 * Examines the lessons of the new and old schedules to determine the delta
	 *
	 * @param array $lessons    the lessons of the new schedule
	 * @param array $refLessons the lessons of the old schedule
	 *
	 * @return void
	 */
	private function setLessonReference($lessons, $refLessons)
	{
		// Check for new lesson data
		foreach ($lessons as $lessonID => $lesson)
		{
			// Lesson only exists in the new schedule
			if (!isset($refLessons->$lessonID))
			{
				$lessons->$lessonID->delta = 'new';
				continue;
			}

			// Lesson exists in both schedules -> compare properties
			$subjectChanges = $this->setPropertyReference($lessons->$lessonID->subjects, $refLessons->$lessonID->subjects);
			$teacherChanges = $this->setPropertyReference($lessons->$lessonID->teachers, $refLessons->$lessonID->teachers);
			$moduleChanges  = $this->setPropertyReference($lessons->$lessonID->pools, $refLessons->$lessonID->pools);

			// Property indexes are not identical
			if ($subjectChanges or $teacherChanges or $moduleChanges)
			{
				$lessons->$lessonID->delta = 'changed';
			}
		}

		// Check for old lesson data
		foreach ($refLessons as $lessonID => $lesson)
		{
			// Lesson only exists in old schedule
			if (!isset($lessons->$lessonID))
			{
				$lessons->$lessonID        = $refLessons->$lessonID;
				$lessons->$lessonID->delta = 'removed';
				continue;
			}
		}
	}

	/**
	 * Creates the delta to the chosen reference schedule
	 *
	 * @param object $reference the reference schedule
	 * @param object $active    the active schedule
	 *
	 * @return boolean true on successful delta creation, otherwise false
	 */
	public function setReference($reference, $active)
	{
		$this->compSchedule = json_decode($reference->schedule);
		$this->schedule     = json_decode($active->schedule);

		// There shouldn't be any delta information in the reference schedule, but this eliminates any possibility of false positives
		$this->sanitize($this->compSchedule);

		// Protect the active delta in case of fail
		$this->_db->transactionStart();
		$this->sanitize($this->schedule);

		$referenceID = $reference->id;
		$reference->set('schedule', json_encode($this->compSchedule));
		$reference->set('active', 0);
		$refSuccess = $reference->store();

		if (!$refSuccess)
		{
			$this->_db->transactionRollback();

			return false;
		}

		$this->schedule->referenceID = $referenceID;

		if (isset($this->schedule->referencedate))
		{
			unset($this->schedule->referencedate);
		}

		$this->setLessonReference($this->schedule->lessons, $this->compSchedule->lessons);
		$this->setCalendarReference($this->schedule->calendar, $this->compSchedule->calendar);

		$active->set('schedule', json_encode($this->schedule));
		$active->set('active', 1);
		$activeSuccess = $active->store();
		if (!$activeSuccess)
		{
			$this->_db->transactionRollback();

			return false;
		}

		$this->_db->transactionCommit();

		return true;
	}

	/**
	 * examines a property of both schedules and creates a delta according to
	 * property indexes
	 *
	 * @param array &$property    the property of the new lesson to be examined
	 * @param array &$refProperty the property of the old lesson to be examined
	 *
	 * @return boolean $changesExist true if a property index is not in both sets
	 */
	private function setPropertyReference(&$property, &$refProperty)
	{
		$changesExist = false;
		foreach ($property as $propertyID => $delta)
		{
			if (!isset($refProperty->$propertyID))
			{
				$property->$propertyID = 'new';
				$changesExist          = true;
				continue;
			}
		}
		foreach ($refProperty as $propertyID => $delta)
		{
			if (!isset($property->$propertyID))
			{
				$property->$propertyID = 'removed';
				$changesExist          = true;
				continue;
			}
		}

		return $changesExist;
	}
}
